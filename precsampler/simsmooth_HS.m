function [fdraw, Ydraw] = simsmooth_HS(Y_o, Y_f, Y_l, Y_u, params, p_z, max_iter)
% ----------------------------------------------------------------------- %
% - This functions draws states and forecasts from a state space model of 
% - the form 
%   y_t = lambda * f_t + e_t
%   e_t = psi * [e_t-1, ..., e_t-Nj] + eps_t; eps_t ~ N(0, sig_eps)
%   f_t = phi  * [f_t-1, ..., f_t-Np] + ups_t; ups_t ~ N(0, sig_ups)
% - Both unconditional and conditional forecasts are supported. For the 
% - both hard, i.e. point restrictions as well as soft, i.e. interval 
% - are allowed. The latter is implemented by drawing unconditional forecasts
% - and discarding any draw that does not satisfy the restrictions. The
% - type of forecast is inferred from the input arguments. Standard
% - arguments are:
% -                 Y_o, Nn x Nt matrix of observables
% -                 params, structure with fields lambda, phi, psi, sig_eps, sig_ups
% -                 p_z, permutation vector generated by p_timet.m
% -                 max_iter, the maximum number of candidate draws from the unrestricted posterior in the case soft conditioning
% - Depending on the type of forecast, the remaining arguments are:
% -                 i ) unconditional forecasting: Y_f = NaN(Nn, Nh) where Nh
% -                 is the forecast horizon, Y_l = Y_u = []
% -                 ii) conditional forecasting (hard): Y_f, partialy observed
% -                 Nn x Nh matrix containing the point restrictions, Y_l = Y_u = []
% -                 iii) conditional forecasting (hard): Y_f = NaN(Nn, Nh),
% -                 Y_l (Y_u), partially observed Nn x Nh matrix containing
% -                 the lower (upper) limits of the interval restrictions
% -                 iv) standard simulation smoothing without forecasting (i.e. Nh = 0) sets 
% -                 Y_f = Y_l = Y_u = []. 
% - The output arguments are: 
% -                 fdraw, Ns x Nt+Nh of sampled states
% -                 Ydraw, Nn x Nt+Nh matrix of forecasts (empty if  Nh = 0)
% ----------------------------------------------------------------------- %

% check args, infer forecast type
if isempty(Y_f) && isempty(Y_u) && isempty(Y_l)
    ftype = 'none';
elseif all(isnan(Y_f), 'all') && isempty(Y_u) && isempty(Y_l)
    ftype = 'unconditional';
elseif any(~isnan(Y_f), 'all') && isempty(Y_u) && isempty(Y_l)
    ftype = 'conditional (hard)';
elseif all(isnan(Y_f), 'all') && ~isempty(Y_u) && ~isempty(Y_l)
    ftype = 'conditional (soft)';
end

% back out dims
[Nn, Nt] = size(Y_o); % # of observations
Nh = size(Y_f, 2); % forecast horizon
NtNh = Nt + Nh; % # of total periods
Ns = size(params.phi, 1); % # of states

% vectorized yobs, removing missings
y = vec([Y_o, Y_f]); 
yobs = y(~isnan(y),1); 
Nmis = sum(isnan(y));
Nobs = sum(~isnan(y));

% precision matrix Q
[PQP_fymis, PQP_fymis_yobs] = construct_PQP(params, NtNh, Nmis, p_z);

% joint draw of f, ymis
chol_PQP_fymis = chol(PQP_fymis, 'lower'); 
b_fymis = rue_held_alg2_1(chol_PQP_fymis, -PQP_fymis_yobs * yobs);
if strcmp(ftype, 'conditional (soft)')       
    % vectorized restrictions
    y_l = [NaN(Ns*NtNh, 1); vec([NaN(size(Y_o)), Y_l])];
    y_l_perm = y_l(p_z.p);
    y_l_perm = y_l_perm(1:end-Nobs);
    ind_l = ~isnan(y_l_perm);
    y_u = [NaN(Ns*NtNh, 1); vec([NaN(size(Y_o)), Y_u])];
    y_u_perm = y_u(p_z.p); 
    y_u_perm = y_u_perm(1:end-Nobs);
    ind_u = ~isnan(y_u_perm);
    % draw proposals
    z_draw = NaN(size(b_fymis, 1), 1);
    iter = 0; 
    while true
        % update iter and check limit
        iter = iter + 1; 
        if iter == max_iter
            error(['Did not obtain an acceptable draw in ' num2str(max_iter) ' attempts. Consider raising the limit or relaxing the restrictions.'])
        end
        % draw candidate
        fxmis_draw = rue_held_alg2_4(chol_PQP_fymis, b_fymis);
        % check soft conditions
        if all(fxmis_draw(ind_l, 1) > y_l_perm(ind_l, 1)) && all(fxmis_draw(ind_u, 1) < y_u_perm(ind_u, 1))
            break; % conditions satisfied!
        end
    end
else
    fxmis_draw = rue_held_alg2_4(chol_PQP_fymis, b_fymis); % draw joint     
end

% reshape draw of z and back out return args
z_draw(p_z.p, :) = [fxmis_draw; repmat(yobs, 1)]; % reverse permutation => z = [vec(f); vec([Y_o, Y_f])]!
fdraw = reshape(z_draw(1:NtNh*Ns, :), Ns, NtNh); 
Ydraw = reshape(z_draw(NtNh*Ns+1:end, :), Nn, NtNh);
if ~strcmp(ftype, 'none') % only return forecasts
    Ydraw = Ydraw(:, Nt+1:NtNh);
else
    Ydraw = [];
end
